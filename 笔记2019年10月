-------2019.10.17（己亥年九月十九）Thu---------
JUC学习
https://www.battleheart.cn

Online Judge
https://www.cnblogs.com/weiyinfu/p/10708677.html

CompletableFuture

Vector---HashTable 自带锁

DelayQueue：按照等待时间进行排序
PriorityQueue：优先队列

Queue对于线程友好的API,offer、peek、poll
BlockingQueue提供put、take阻塞方法（方便实现生产-消费者模型）

BlockingQueue：
LinkedBlockingQueue(无界队列）
ArrayBlockingQueue(有界队列)
队列满了
add阻塞
offer不阻塞直接返回false



底层阻塞是通过LockSupport.park()
ReentrantLock.


SynchronousQueue（同步队列）队列长度为0，专门用作线程间交换数据
TransferQueue（传递队列）装完--等待---取走

Exchanger.change


-------2019.10.16（己亥年九月十八）Web---------
设计模式：Chain Of Responsibility
javax.servlet
Interface Filter
doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
          The doFilter method of the Filter is called by the container each time a request/response pair is passed through the chain due to a client request for a resource at the end of the chain.
		  
javax.servlet
Interface FilterChain



设计模式：
1、Iterator模式
2、Visitor模式----结合asm看visitor模式
3、Builder模式



ThreadLocal
WeakReference<M> m = new WeakReference<>(new M());
经过System.gc();后，m就被垃圾回收

作业：
WeakHashMap的用处
读AQS unlock的源码


ThreadLocal
	static class ThreadLocalMap 
			static class Entry extends WeakReference<ThreadLocal<?>>
					Entry(ThreadLocal<?> k, Object v)
					


ThreadLocal<M> tl = new ThreadLocal<>();
tl.set(new M());
//!!!使用ThreadLocal之后，记得remove
tl.remove();



容器-Vector-Hashtable
CopyOnWriteList
ConcurrentHashMap
ConcurrentSkipListMap
BlockingQueue
目标：为ThreadPool做准备


-------2019.10.15（己亥年九月十七）Tue---------
多线程高并发
redis
SpringCloud微服务

直播平台
客户端：obs studio
服务端：nginx+rtmp插件




设计模式：Adapter模式
 //将字节流转化为字符流	 
 InputStream in = new FileInputStream("C:/hello.txt");
 InputStreamReader isr = new InputStreamReader(in);

-------2019.10.14（己亥年九月十六）Mon---------
知识点1：DevOps
 DevOps一词的来自于Development和Operations的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。
 DevOps希望做到的是软件产品交付过程中IT工具链的打通，使得各个团队减少时间损耗，更加高效地协同工作。
 现代化的DevOps工具，如Chef、Docker、Ansible、Packer、Troposphere、Consul、Jenkins、SonarQube、AWS等

知识点：Netty
https://netty.io/wiki/related-articles.html
Netty:Bootstrap的handler和childHandler

netty官网概览
https://netty.io/4.0/xref/



学习目标：
有较扎实的Java基础知识，能够熟练使用Java相关技术进行独立开发；
熟悉Java多线程、并发库、熟悉TCP/IP协议，NIO，熟悉Netty框架，基础的算法和数据结构；
熟悉MySql数据库及MySql的优化，熟悉protobuf协议；
熟悉Maven构建工具；


精通Java，多线程编程，消息系统，数据库，分布式应用等技术，对SOA框架有较深刻的理解；
熟悉网络编程，具有设计和开发对外API接口经验和能力；
有Hadoop、Spark、Hive等相关经验者优先；




-------2019.10.13（己亥年九月十五）Sun---------
netty客户端编程
BootStrap
EventLoopGroup接口实现类 NioEventLoopGroup（本质是一个线程池）

ChannelFuture
ChannelInitializer<SocketChannel>

Lombok插件

http://yapi.demo.qunar.com/
高效、易用、功能强大的API管理平台
旨在为开发、产品、测试人员提供更优雅的接口管理服务


1、Template模式
2、State模式？
3、Intepreter


-------2019.10.12（己亥年九月十四）Sat---------
分布式系统
An Illustrated Proof of the CAP Theorem
https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/
Consistency 一致性
Availability 可用性
Partition tolerance 分区容错性







Proxy模式：
JDK动态代理    关键API:Proxy InvocationHandler  缺点：被代理对象必须实现接口
cglib动态代理  关键API:Enhancer+MethodInterceptor 优点：被代理对象无需实现接口，使用简单 缺点：不能代理final对象
org.objectweb.asm 小而快速的字节码操作框架     缺点：直接修改字节码，使用复杂
asm官网
https://gitlab.ow2.org/asm/asm
https://asm.ow2.io/


javaassist简要介绍
和AOP有什么关系和区别？CGLib是动态代理的经典类库，其底层实现使用ASM

Java bytecode engineering toolkit http://www.javassist.org
javassist底层实现类似ASM
Javassist (JAVA programming ASSISTant) 是在 Java 中编辑字节码的类库;它使 Java 程序能够在运行时定义一个新类, 并在 JVM 加载时修改类文件。
我们常用到的动态特性主要是反射，在运行时查找对象属性、方法，修改作用域，通过方法名称调用方法等。
在线的应用不会频繁使用反射，因为反射的性能开销较大。其实还有一种和反射一样强大的特性，但是开销却很低，它就是Javassit。
与其他类似的字节码编辑器不同, Javassist 提供了两个级别的 API: 源级别和字节码级别。 
如果用户使用源级 API, 他们可以编辑类文件, 而不知道 Java 字节码的规格。 整个 API 只用 Java 语言的词汇来设计。 您甚至可以以源文本的形式指定插入的字节码; Javassist 在运行中编译它


java.lang.instrument

提供允许 Java 编程语言代理检测运行在 JVM 上的程序的服务



多线程高并发
java.util.concurrent
Interface Future<V>

java.util.concurrent
Interface Callable<V>


java.util.concurrent
Class FutureTask<V>
All Implemented Interfaces:Runnable, Future<V>, RunnableFuture<V>

-------2019.10.11（己亥年九月十三）Fri---------
GoF《设计模式》
Facade模式（封装内部逻辑细节，对外提供简化接口）
Decorator模式：不改变原对象的前提下，扩展原对象的功能（不使用继承）
	File f1 = new File("D:\\Rain.txt");
	FileInputStream fis = new FileInputStream(f1);
	BufferedInputStream bis = new BufferedInputStream(fis);//为FileInputStream增加了缓冲功能



Proxy模式：

WeakHashMap




栈stack内存--->存储函数的主体和变量名
堆heap内存---->堆内存是用来存储实例(实例化后的对象实体)的
引用名都放在栈内存,值放堆内存

栈内存是线程私有的，堆内存是公共的



-------2019.10.10（己亥年九月十二）Thu---------
VarHandle
java四种引用：强、软、弱、虚
    软引用和弱引用的价值：
    适合保存那些可有可无的缓存数据，当内存不足时，缓存数据被回收（再通过备选方案查询），当内存充足时，也可以存在较长时间，起到加速的作用。
异或位操作
容器
